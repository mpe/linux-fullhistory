#
# For a description of the syntax of this configuration file,
# see Documentation/kbuild/kconfig-language.txt.
#
# Note: ISA is disabled and will hopefully never be enabled.
# If you managed to buy an ISA x86-64 box you'll have to fix all the
# ISA drivers you need yourself. 
#

mainmenu "Linux Kernel Configuration"

config X86_64
	bool
	default y
	help
	  Port to the x86-64 architecture. x86-64 is an 64bit extension to the
	  classical 32bit x86 architecture. For details see http://www.x86-64.org

config X86
	bool
	default y
	help
	  This is Linux's home port.  Linux was originally native to the Intel
	  386, and runs on all the later x86 processors including the Intel
	  486, 586, Pentiums, and various instruction-set-compatible chips by
	  AMD, Cyrix, and others.

config MMU
	bool
	default y

config SWAP
	bool
	default y

config ISA
	bool
	help
	  Find out whether you have ISA slots on your motherboard.  ISA is the
	  name of a bus system, i.e. the way the CPU talks to the other stuff
	  inside your box.  Other bus systems are PCI, EISA, MicroChannel
	  (MCA) or VESA.  ISA is an older system, now being displaced by PCI;
	  newer boards don't support it.  If you have ISA, say Y, otherwise N.

config SBUS
	bool

config UID16
	bool
	default y

config RWSEM_GENERIC_SPINLOCK
	bool
	default y

config RWSEM_XCHGADD_ALGORITHM
	bool

config X86_CMPXCHG
	bool
	default y

config EARLY_PRINTK
	bool
	default y
	help
	  Write kernel log output directly into the VGA buffer. This is useful
	  for kernel debugging when your machine crashes very early before
	  the console code is initialized. For normal operation it is not
	  recommended because it looks ugly and doesn't cooperate with 
	  klogd/syslogd or the X server.You should normally N here, unless
	  you want to debug such a crash.
	  

config GENERIC_ISA_DMA
	bool
	default y

source "init/Kconfig"


menu "Processor type and features"

choice
	prompt "Processor family"
	default MK8

config MK8
	bool "AMD-Hammer"
	help
	  Support for AMD Clawhammer/Sledgehammer CPUs. Only choice for x86-64
	  currently so you should chose this if you want a x86-64 kernel. In fact
	  you will have no other choice than to chose this.

config GENERIC_CPU
	bool "Generic-x86-64"

endchoice

#
# Define implied options from the CPU selection here
#
config X86_L1_CACHE_BYTES
	int
	default "64"

config X86_L1_CACHE_SHIFT
	int
	default "6"

config X86_TSC
	bool
	default y

config X86_GOOD_APIC
	bool
	default y

config X86_MSR
	tristate "/dev/cpu/*/msr - Model-specific register support"
	help
	  This device gives privileged processes access to the x86
	  Model-Specific Registers (MSRs).  It is a character device with
	  major 202 and minors 0 to 31 for /dev/cpu/0/msr to /dev/cpu/31/msr.
	  MSR accesses are directed to a specific CPU on multi-processor
	  systems.

config X86_CPUID
	tristate "/dev/cpu/*/cpuid - CPU information support"
	help
	  This device gives processes access to the x86 CPUID instruction to
	  be executed on a specific processor.  It is a character device
	  with major 203 and minors 0 to 31 for /dev/cpu/0/cpuid to
	  /dev/cpu/31/cpuid.

config MATH_EMULATION
	bool

config MCA
	bool

config EISA
	bool

config X86_IO_APIC
	bool
	default y

config X86_LOCAL_APIC
	bool
	default y

config MTRR
	bool "MTRR (Memory Type Range Register) support"
	---help---
	  On Intel P6 family processors (Pentium Pro, Pentium II and later)
	  the Memory Type Range Registers (MTRRs) may be used to control
	  processor access to memory ranges. This is most useful if you have
	  a video (VGA) card on a PCI or AGP bus. Enabling write-combining
	  allows bus write transfers to be combined into a larger transfer
	  before bursting over the PCI/AGP bus. This can increase performance
	  of image write operations 2.5 times or more. Saying Y here creates a
	  /proc/mtrr file which may be used to manipulate your processor's
	  MTRRs. Typically the X server should use this.

	  This code has a reasonably generic interface so that similar
	  control registers on other processors can be easily supported
	  as well:

	  Saying Y here also fixes a problem with buggy SMP BIOSes which only
	  set the MTRRs for the boot CPU and not for the secondary CPUs. This
	  can lead to all sorts of problems, so it's good to say Y here.

	  Just say Y here, all x86-64 machines support MTRRs.

	  See <file:Documentation/mtrr.txt> for more information.

config HUGETLB_PAGE
	bool "Huge TLB Page Support"
	help
	  This enables support for huge pages.  User space applications
	  can make use of this support with the hugetlbfs file system
	  To actually use it you need to pass an hugepages= argument
	  to the kernel at boot time.

config SMP
	bool "Symmetric multi-processing support"
	---help---
	  This enables support for systems with more than one CPU. If you have
	  a system with only one CPU, like most personal computers, say N. If
	  you have a system with more than one CPU, say Y.

	  If you say N here, the kernel will run on single and multiprocessor
	  machines, but will use only one CPU of a multiprocessor machine. If
	  you say Y here, the kernel will run on many, but not all,
	  singleprocessor machines. On a singleprocessor machine, the kernel
	  will run faster if you say N here.

	  Note that if you say Y here and choose architecture "586" or
	  "Pentium" under "Processor family", the kernel will not work on 486
	  architectures. Similarly, multiprocessor kernels for the "PPro"
	  architecture may not work on all Pentium based boards.

	  People using multiprocessor machines who say Y here should also say
	  Y to "Enhanced Real Time Clock Support", below. The "Advanced Power
	  Management" code will be disabled if you say Y here.

	  See also the <file:Documentation/smp.tex>,
	  <file:Documentation/smp.txt>, <file:Documentation/i386/IO-APIC.txt>,
	  <file:Documentation/nmi_watchdog.txt> and the SMP-HOWTO available at
	  <http://www.linuxdoc.org/docs.html#howto>.

	  If you don't know what to do here, say N.

config PREEMPT
	bool "Preemptible Kernel"
	depends on !SMP
	---help---
	  This option reduces the latency of the kernel when reacting to
	  real-time or interactive events by allowing a low priority process to
	  be preempted even if it is in kernel mode executing a system call.
	  This allows applications to run more reliably even when the system is
	  under load. On contrary it may also break your drivers and add
	  priority inheritance problems to your system. Don't select it if 
	  you rely on a stable system or have slightly obscure hardware.
	  It's also not very well tested on x86-64 currently.
	  You have been warned.

	  Say Y here if you are feeling brave and building a kernel for a 
	  desktop, embedded or real-time system.  Say N if you are unsure. 

config HAVE_DEC_LOCK
	bool
	depends on SMP
	default y

# actually 64 maximum, but you need to fix the APIC code first
# to use clustered mode or whatever your big iron needs
config NR_CPUS
	int "Maximum number of CPUs (2-8)"
	depends on SMP
	default "8"
	help
	  This allows you to specify the maximum number of CPUs which this
	  kernel will support.  The maximum supported value is 32 and the
	  minimum value which makes sense is 2.

	  This is purely to save memory - each supported CPU adds
	  approximately eight kilobytes to the kernel image.

config GART_IOMMU
	bool "IOMMU support"
	help
	  Support the K8 IOMMU. Needed to run systems with more than 4GB of memory
	  properly with 32bit devices. You should probably turn this on.
	  The iommu can be turned off at runtime with the iommu=off parameter.

config DUMMY_IOMMU
	bool
	depends on !GART_IOMMU
	default y
	help
	  Don't use IOMMU code. This will cause problems when you have more than 4GB 
	  of memory and any 32bit devices. Don't turn on unless you know what you
	  are doing.

config X86_MCE
	bool
	default y

endmenu


menu "Power management options"

config PM
	bool "Power Management support"
	---help---
	  "Power Management" means that parts of your computer are shut
	  off or put into a power conserving "sleep" mode if they are not
	  being used.  There are two competing standards for doing this: APM
	  and ACPI.  If you want to use either one, say Y here and then also
	  to the requisite support below.

	  Power Management is most important for battery powered laptop
	  computers; if you have a laptop, check out the Linux Laptop home
	  page on the WWW at
	  <http://www.cs.utexas.edu/users/kharker/linux-laptop/> and the
	  Battery Powered Linux mini-HOWTO, available from
	  <http://www.linuxdoc.org/docs.html#howto>.

	  Note that, even if you say N here, Linux on the x86 architecture
	  will issue the hlt instruction if nothing is to be done, thereby
	  sending the processor to sleep and saving power.

config SOFTWARE_SUSPEND
	bool "Software Suspend (EXPERIMENTAL)"
	depends on EXPERIMENTAL && PM
	---help---
	  Enable the possibilty of suspendig machine. It doesn't need APM.
	  You may suspend your machine by 'swsusp' or 'shutdown -z <time>' 
	  (patch for sysvinit needed). 

	  It creates an image which is saved in your active swaps. By the next
	  booting the, pass 'resume=/path/to/your/swap/file' and kernel will 
	  detect the saved image, restore the memory from
	  it and then it continues to run as before you've suspended.
	  If you don't want the previous state to continue use the 'noresume'
	  kernel option. However note that your partitions will be fsck'd and
	  you must re-mkswap your swap partitions/files.

	  Right now you may boot without resuming and then later resume but
	  in meantime you cannot use those swap partitions/files which were
	  involved in suspending. Also in this case there is a risk that buffers
	  on disk won't match with saved ones.

	  SMP is supported ``as-is''. There's a code for it but doesn't work.
	  There have been problems reported relating SCSI.

	  This option is about getting stable. However there is still some
	  absence of features.

	  For more information take a look at Documentation/swsusp.txt.

source "drivers/acpi/Kconfig"

endmenu


menu "Bus options (PCI etc.)"

config PCI
	bool "PCI support"
	help
	  Find out whether you have a PCI motherboard. PCI is the name of a
	  bus system, i.e. the way the CPU talks to the other stuff inside
	  your box. Other bus systems are ISA, EISA, MicroChannel (MCA) or
	  VESA. If you have PCI, say Y, otherwise N.

	  The PCI-HOWTO, available from
	  <http://www.linuxdoc.org/docs.html#howto>, contains valuable
	  information about which PCI hardware does work under Linux and which
	  doesn't.

# x86-64 doesn't support PCI BIOS access from long mode so always go direct. 
config PCI_DIRECT
	bool
	depends on PCI
	default y

source "drivers/pci/Kconfig"

config HOTPLUG
	bool "Support for hot-pluggable devices"
	---help---
	  Say Y here if you want to plug devices into your computer while
	  the system is running, and be able to use them quickly.  In many
	  cases, the devices can likewise be unplugged at any time too.

	  One well known example of this is PCMCIA- or PC-cards, credit-card
	  size devices such as network cards, modems or hard drives which are
	  plugged into slots found on all modern laptop computers.  Another
	  example, used on modern desktops as well as laptops, is USB.

	  Enable HOTPLUG and KMOD, and build a modular kernel.  Get agent
	  software (at <http://linux-hotplug.sourceforge.net/>) and install it.
	  Then your kernel will automatically call out to a user mode "policy
	  agent" (/sbin/hotplug) to load modules and set up software needed
	  to use devices as you hotplug them.

source "drivers/pcmcia/Kconfig"

source "drivers/hotplug/Kconfig"

endmenu


menu "Executable file formats / Emulations"

config KCORE_ELF
	bool
	depends on PROC_FS
	default y
	---help---
	  If you enabled support for /proc file system then the file
	  /proc/kcore will contain the kernel core image. This can be used
	  in gdb:

	  $ cd /usr/src/linux ; gdb vmlinux /proc/kcore

	  You have two choices here: ELF and A.OUT. Selecting ELF will make
	  /proc/kcore appear in ELF core format as defined by the Executable
	  and Linking Format specification. Selecting A.OUT will choose the
	  old "a.out" format which may be necessary for some old versions
	  of binutils or on some architectures.

	  This is especially useful if you have compiled the kernel with the
	  "-g" option to preserve debugging information. It is mainly used
	  for examining kernel data structures on the live kernel so if you
	  don't understand what this means or are not a kernel hacker, just
	  leave it at its default value ELF.

#tristate 'Kernel support for a.out binaries' CONFIG_BINFMT_AOUT
config BINFMT_ELF
	tristate "Kernel support for ELF binaries"
	---help---
	  ELF (Executable and Linkable Format) is a format for libraries and
	  executables used across different architectures and operating
	  systems. Saying Y here will enable your kernel to run ELF binaries
	  and enlarge it by about 13 KB. ELF support under Linux has now all
	  but replaced the traditional Linux a.out formats (QMAGIC and ZMAGIC)
	  because it is portable (this does *not* mean that you will be able
	  to run executables from different architectures or operating systems
	  however) and makes building run-time libraries very easy. Many new
	  executables are distributed solely in ELF format. You definitely
	  want to say Y here.

	  Information about ELF is contained in the ELF HOWTO available from
	  <http://www.linuxdoc.org/docs.html#howto>.

	  If you find that after upgrading from Linux kernel 1.2 and saying Y
	  here, you still can't run any ELF binaries (they just crash), then
	  you'll have to install the newest ELF runtime libraries, including
	  ld.so (check the file <file:Documentation/Changes> for location and
	  latest version).

	  If you want to compile this as a module ( = code which can be
	  inserted in and removed from the running kernel whenever you want),
	  say M here and read <file:Documentation/modules.txt>.  The module
	  will be called binfmt_elf.o. Saying M or N here is dangerous because
	  some crucial programs on your system might be in ELF format.

config BINFMT_MISC
	tristate "Kernel support for MISC binaries"
	---help---
	  If you say Y here, it will be possible to plug wrapper-driven binary
	  formats into the kernel. You will like this especially when you use
	  programs that need an interpreter to run like Java, Python or
	  Emacs-Lisp. It's also useful if you often run DOS executables under
	  the Linux DOS emulator DOSEMU (read the DOSEMU-HOWTO, available from
	  <http://www.linuxdoc.org/docs.html#howto>). Once you have
	  registered such a binary class with the kernel, you can start one of
	  those programs simply by typing in its name at a shell prompt; Linux
	  will automatically feed it to the correct interpreter.

	  You can do other nice things, too. Read the file
	  <file:Documentation/binfmt_misc.txt> to learn how to use this
	  feature, and <file:Documentation/java.txt> for information about how
	  to include Java support.

	  You must say Y to "/proc file system support" (CONFIG_PROC_FS) to
	  use this part of the kernel.

	  You may say M here for module support and later load the module when
	  you have use for it; the module is called binfmt_misc.o. If you
	  don't know what to answer at this point, say Y.

config IA32_EMULATION
	bool "IA32 Emulation"
	help
	  Include code to run 32bit programs under an 64bit kernel. You should likely
	  turn this on, unless you're 100% sure that you don't have any 32bit programs
	  left.

config COMPAT
	bool
	depends on IA32_EMULATION
	default y

endmenu

source "drivers/mtd/Kconfig"

source "drivers/parport/Kconfig"

source "drivers/block/Kconfig"


menu "ATA/ATAPI/MFM/RLL support"

config IDE
	tristate "ATA/ATAPI/MFM/RLL device support"
	---help---
	  If you say Y here, your kernel will be able to manage low cost mass
	  storage units such as ATA/(E)IDE and ATAPI units. The most common
	  cases are IDE hard drives and ATAPI CD-ROM drives.

	  If your system is pure SCSI and doesn't use these interfaces, you
	  can say N here.

	  Integrated Disk Electronics (IDE aka ATA-1) is a connecting standard
	  for mass storage units such as hard disks. It was designed by
	  Western Digital and Compaq Computer in 1984. It was then named
	  ST506. Quite a number of disks use the IDE interface.

	  AT Attachment (ATA) is the superset of the IDE specifications.
	  ST506 was also called ATA-1.

	  Fast-IDE is ATA-2 (also named Fast ATA), Enhanced IDE (EIDE) is
	  ATA-3. It provides support for larger disks (up to 8.4GB by means of
	  the LBA standard), more disks (4 instead of 2) and for other mass
	  storage units such as tapes and cdrom. UDMA/33 (aka UltraDMA/33) is
	  ATA-4 and provides faster (and more CPU friendly) transfer modes
	  than previous PIO (Programmed processor Input/Output) from previous
	  ATA/IDE standards by means of fast DMA controllers.

	  ATA Packet Interface (ATAPI) is a protocol used by EIDE tape and
	  CD-ROM drives, similar in many respects to the SCSI protocol.

	  SMART IDE (Self Monitoring, Analysis and Reporting Technology) was
	  designed in order to prevent data corruption and disk crash by
	  detecting pre hardware failure conditions (heat, access time, and
	  the like...). Disks built since June 1995 may follow this standard.
	  The kernel itself don't manage this; however there are quite a
	  number of user programs such as smart that can query the status of
	  SMART parameters disk.

	  If you want to compile this driver as a module ( = code which can be
	  inserted in and removed from the running kernel whenever you want),
	  say M here and read <file:Documentation/modules.txt>. The module
	  will be called ide.o.

	  For further information, please read <file:Documentation/ide.txt>.

	  If unsure, say Y.

source "drivers/ide/Kconfig"

endmenu


menu "SCSI device support"

config SCSI
	tristate "SCSI device support"
	---help---
	  If you want to use a SCSI hard disk, SCSI tape drive, SCSI CD-ROM or
	  any other SCSI device under Linux, say Y and make sure that you know
	  the name of your SCSI host adapter (the card inside your computer
	  that "speaks" the SCSI protocol, also called SCSI controller),
	  because you will be asked for it.

	  You also need to say Y here if you want support for the parallel
	  port version of the 100 MB IOMEGA ZIP drive.

	  This driver is also available as a module ( = code which can be
	  inserted in and removed from the running kernel whenever you want).
	  The module will be called scsi_mod.o.  If you want to compile it as
	  a module, say M here and read <file:Documentation/modules.txt> and
	  <file:Documentation/scsi/scsi.txt>.  However, do not compile this as a
	  module if your root file system (the one containing the directory /)
	  is located on a SCSI device.

source "drivers/scsi/Kconfig"

endmenu

source "drivers/md/Kconfig"

source "drivers/telephony/Kconfig"

source "drivers/message/fusion/Kconfig"

source "drivers/ieee1394/Kconfig"

#Currently not 64bit safe
#source drivers/message/i2o/Config.in
source "net/Kconfig"


menu "Network device support"
	depends on NET

config NETDEVICES
	bool "Network device support"
	---help---
	  You can say N here if you don't intend to connect your Linux box to
	  any other computer at all or if all your connections will be over a
	  telephone line with a modem either via UUCP (UUCP is a protocol to
	  forward mail and news between unix hosts over telephone lines; read
	  the UUCP-HOWTO, available from
	  <http://www.linuxdoc.org/docs.html#howto>) or dialing up a shell
	  account or a BBS, even using term (term is a program which gives you
	  almost full Internet connectivity if you have a regular dial up
	  shell account on some Internet connected Unix computer. Read
	  <http://www.bart.nl/~patrickr/term-howto/Term-HOWTO.html>).

	  You'll have to say Y if your computer contains a network card that
	  you want to use under Linux (make sure you know its name because you
	  will be asked for it and read the Ethernet-HOWTO (especially if you
	  plan to use more than one network card under Linux)) or if you want
	  to use SLIP (Serial Line Internet Protocol is the protocol used to
	  send Internet traffic over telephone lines or null modem cables) or
	  CSLIP (compressed SLIP) or PPP (Point to Point Protocol, a better
	  and newer replacement for SLIP) or PLIP (Parallel Line Internet
	  Protocol is mainly used to create a mini network by connecting the
	  parallel ports of two local machines) or AX.25/KISS (protocol for
	  sending Internet traffic over amateur radio links).

	  Make sure to read the NET-3-HOWTO. Eventually, you will have to read
	  Olaf Kirch's excellent and free book "Network Administrator's
	  Guide", to be found in <http://www.linuxdoc.org/docs.html#guide>. If
	  unsure, say Y.

source "drivers/net/Kconfig"

# ATM seems to be largely 64bit unsafe and also unmaintained - disable it for now.
#      if [ "$CONFIG_ATM" = "y" ]; then
#         source drivers/atm/Config.in
#      fi
endmenu

source "net/ax25/Kconfig"

source "net/irda/Kconfig"

source "drivers/isdn/Kconfig"

# no support for non IDE/SCSI cdroms as they were all ISA only
#
# input before char - char/joystick depends on it. As does USB.
#
source "drivers/input/Kconfig"

source "drivers/char/Kconfig"

source "drivers/misc/Kconfig"

source "drivers/media/Kconfig"

source "fs/Kconfig"

source "drivers/video/Kconfig"

menu "Sound"

config SOUND
	tristate "Sound card support"
	---help---
	  If you have a sound card in your computer, i.e. if it can say more
	  than an occasional beep, say Y.  Be sure to have all the information
	  about your sound card and its configuration down (I/O port,
	  interrupt and DMA channel), because you will be asked for it.

	  You want to read the Sound-HOWTO, available from
	  <http://www.linuxdoc.org/docs.html#howto>. General information about
	  the modular sound system is contained in the files
	  <file:Documentation/sound/Introduction>.  The file
	  <file:Documentation/sound/README.OSS> contains some slightly
	  outdated but still useful information as well.

	  If you have a PnP sound card and you want to configure it at boot
	  time using the ISA PnP tools (read
	  <http://www.roestock.demon.co.uk/isapnptools/>), then you need to
	  compile the sound card support as a module ( = code which can be
	  inserted in and removed from the running kernel whenever you want)
	  and load that module after the PnP configuration is finished.  To do
	  this, say M here and read <file:Documentation/modules.txt> as well
	  as <file:Documentation/sound/README.modules>; the module will be
	  called soundcore.o.

	  I'm told that even without a sound card, you can make your computer
	  say more than an occasional beep, by programming the PC speaker.
	  Kernel patches and supporting utilities to do that are in the pcsp
	  package, available at <ftp://ftp.infradead.org/pub/pcsp/>.

source "sound/Kconfig"

endmenu

source "drivers/usb/Kconfig"

source "net/bluetooth/Kconfig"


menu "Kernel hacking"

config DEBUG_KERNEL
	bool "Kernel debugging"
	help
	  Say Y here if you are developing drivers or trying to debug and
	  identify kernel problems.

config DEBUG_SLAB
	bool "Debug memory allocations"
	depends on DEBUG_KERNEL
	help
	  Say Y here to have the kernel do limited verification on memory
	  allocation as well as poisoning memory on free to catch use of freed
	  memory.

#   bool '  Memory mapped I/O debugging' CONFIG_DEBUG_IOVIRT
config MAGIC_SYSRQ
	bool "Magic SysRq key"
	depends on DEBUG_KERNEL
	help
	  If you say Y here, you will have some control over the system even
	  if the system crashes for example during kernel debugging (e.g., you
	  will be able to flush the buffer cache to disk, reboot the system
	  immediately or dump some status information). This is accomplished
	  by pressing various keys while holding SysRq (Alt+PrintScreen). It
	  also works on a serial console (on PC hardware at least), if you
	  send a BREAK and then within 5 seconds a command keypress. The
	  keys are documented in <file:Documentation/sysrq.txt>. Don't say Y
	  unless you really know what this hack does.

config DEBUG_SPINLOCK
	bool "Spinlock debugging"
	depends on DEBUG_KERNEL
	help
	  Say Y here and build SMP to catch missing spinlock initialization
	  and certain other kinds of spinlock errors commonly made.  This is
	  best used in conjunction with the NMI watchdog so that spinlock
	  deadlocks are also debuggable.

config CHECKING
	bool "Additional run-time checks"
	depends on DEBUG_KERNEL
	help
	  Enables some internal consistency checks for kernel debugging.
	  You should normally say N.

config INIT_DEBUG
	bool "Debug __init statements"
	depends on DEBUG_KERNEL
	help
	  Fill __init and __initdata at the end of boot. This is only for debugging.

config KALLSYMS
	bool "Load all symbols for debugging/kksymoops"
	depends on DEBUG_KERNEL
	help
	  Say Y here to let the kernel print out symbolic crash information and
	  symbolic stack backtraces. This increases the size of the kernel
	  somewhat, as all symbols have to be loaded into the kernel image.

config FRAME_POINTER
       bool "Compile the kernel with frame pointers"
       depends on DEBUG_KERNEL	
       help
         If you say Y here the resulting kernel image will be slightly larger
         and slower, but it will give very useful debugging information.
         If you don't debug the kernel, you can say N, but we may not be able
         to solve problems without frame pointers.
	 Note this is normally not needed on x86-64.

endmenu

source "security/Kconfig"

source "crypto/Kconfig"

source "lib/Kconfig"

