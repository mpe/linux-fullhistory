     Kernel Support for miscellaneous (your favourite) Binary Formats v1.1
     =====================================================================

This Kernel feature allows to invoke almost (for restrictions see below) every
program by simply typing its name in the shell.
This includes for example compiled Java(TM), Python or Emacs programs.

To achieve this you must tell binfmt_misc which interpreter has to be invoked
with which binary. Binfmt_misc recognises the binary-type by matching some bytes
at the beginning of the file with a magic byte sequence (masking out specified
bits) you have supplied. Binfmt_misc can also recognise a filename extension
(aka .com) and optionally strip it off.

To actually register a new binary type, you have to set up a string looking like
:name:type:offset:magic:mask:interpreter: (where you can choose the ':' upon
your needs) and echo it to /proc/sys/fs/binfmt_misc/register.
Here is what the fields mean:
 - 'name' is an identifier string. A new /proc file will be created with this
   name below /proc/sys/fs/binfmt_misc
 - 'type' is the type of recognition. Give 'M' for magic and 'E' for extension.
   Give the corresponding lowercase letter to let binfmt_misc strip off the
   filename extension.
 - 'offset' is the offset of the magic/mask in the file, counted in bytes. This
   defaults to 0 if you omit it (i.e. you write ':name:type::magic...')
 - 'magic' is the byte sequence binfmt_misc is matching for. The magic string
   may contain hex-encoded characters like \x0a or \xA4. In a shell environment
   you will have to write \\x0a to prevent the shell from eating your \.
   If you chose filename extension matching, this is the extension to be
   recognised (the \x0a specials are not allowed). Extension matching is case
   sensitive!
 - 'mask' is an (optional, defaults to all 0xff) mask. You can mask out some
   bits from matching by supplying a string like magic and as long as magic.
   The mask is anded with the byte sequence of the file.
 - 'interpreter' is the program that should be invoked with the binary as first
   argument (specify the full path)
There are some restrictions:
 - the whole register string may not exceed 255 characters
 - the magic must resist in the first 128 bytes of the file, i.e.
   offset+size(magic) has to be less than 128
 - the interpreter string may not exceed 127 characters
You may want to add the binary formats in one of your /etc/rc scripts during
boot-up. Read the manual of your init program to figure out how to do this
right.


A few examples (assumed you are in /proc/sys/fs/binfmt_misc):

- enable support for em86 (like binfmt_em86, for Alpha AXP only):
  echo ":i386:M::\x7fELF\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x03:\xff\xff\xff\xff\xff\xfe\xfe\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfb\xff\xff:/bin/em86:" > register
  echo ":i486:M::\x7fELF\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x06:\xff\xff\xff\xff\xff\xfe\xfe\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfb\xff\xff:/bin/em86:" > register

- enable support for packed DOS applications (pre-configured dosemu hdimages):
  echo ":DEXE:M::\x0eDEX::/usr/bin/dosexec:" > register

- enable support for DOS/Windows executables (using mzloader and dosemu/wine):
  echo ":DOSWin:M::MZ::/usr/sbin/mzloader:" > register
  echo ":DOScom:E::com::/usr/sbin/mzloader:" > register
  echo ":DOSexe:E::exe::/usr/sbin/mzloader:" > register


You can enable/disable binfmt_misc or one binary type by echoing 0 (to disable)
or 1 (to enable) to /proc/sys/fs/binfmt_misc/status or /proc/.../the_name.
Catting the file tells you the current status of binfmt_misc/the entry.

You can remove one entry or all entries by echoing -1 to /proc/.../the_name
or /proc/sys/fs/binfmt_misc/status.


Emulating binfmt_java:
======================

To emulate binfmt_java the following register-strings could be used: 
for compiled Java programs use
  ":Java:M::\xca\xfe\xba\xbe::/usr/local/java/bin/javawrapper:"
for simple applet support use
  ":Applet:E::html::/usr/local/java/bin/appletviewer:"
for more selective applet support (like binfmt_java) use
  ":Applet:M::\<\!--applet::/usr/local/java/bin/appletviewer:"

Note, that for the more selective applet support you have to modify
existing html-files to contain <!--applet--> in the first line to
let this work!

For the compiled Java programs you need a wrapper script like the
following (this is because Java is broken in case of the filename
handling):

====================== Cut here ===================
#!/bin/bash
# /usr/local/java/bin/javawrapper - the wrapper for binfmt_misc/java
CLASS=$1

# if classname is a link, we follow it (this could be done easier - how?)
if [ -L "$1" ] ; then
	CLASS=`ls --color=no -l $1 | tr -s '\t ' '  ' | cut -d ' ' -f 11` 
fi
CLASSN=`basename $CLASS | sed s/\.class$//`
CLASSP=`dirname $CLASS`

FOO=$PATH
PATH=$CLASSPATH
if [ -z "`type -p -a $CLASSN.class`" ] ; then
	# class is not in CLASSPATH
	if [ -e "$CLASSP/$CLASSN.class" ] ; then
		# append dir of class to CLASSPATH
		if [ -z "${CLASSPATH}" ] ; then
			export CLASSPATH=$CLASSP
		else
			export CLASSPATH=$CLASSP:$CLASSPATH
		fi
	else
		# uh! now we would have to create a symbolic link - really
		# ugly, i.e. print a message that one has to change the setup
		echo "Hey! This is not a good setup to run $1 !"
		exit 1
	fi
fi
PATH=$FOO

shift
/usr/local/java/bin/java $CLASSN $@
====================== Cut here ===================

To add a Java program to your path best put a symbolic link to the main
.class file into /usr/bin (or another place you like) omitting the .class
extension. The directory containing the original .class file will be
added to your CLASSPATH during execution.



HINTS:
======

If you want to pass special arguments to your interpreter, you can
write a wrapper script for it.

Your interpreter should NOT look in the PATH for the filename; the
kernel passes it the full filename to use.  Using the PATH can cause
unexpected behaviour and be a security hazard.


There is a web page about binfmt_misc at
http://www.anatom.uni-tuebingen.de/~richi/linux/binfmt_misc.html

Richard Günther, richard.guenther@student.uni-tuebingen.de
