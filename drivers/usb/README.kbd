This is a simple USB keyboard driver written from Linus'
USB driver (started with Greg's usb-0.03b.tar.gz source
tree)

It works fine with my BTC keyboard but I'm still investigating
trouble with my MS keyboard (trouble starts with an inability
to set into boot protocol mode, though, this very well could
be all due to crappy hardware).

Anyway, I would appreciate you taking a look if you have
any USB keyboards lying around.  Oh also, I'm doing this on
UHCI so sorry if it breaks with OHCI.

-ham



Keyboard patch
--------------

Instead of using the multiple keyboard patch and then running into all
of the kernel version problems that the current Linux-USB project has
had, I'm just mapping the USB keycodes to the standard AT-101 keycodes
and sending them directly to "handle_scancode".

This may or may not be considered a hack.  Anyway it is effective, and
I think safe, and allows USB keyboards to coexist with a serial
keyboard (oh yeah, one side effect is that you can for example hold
down the control key on the serial keyboard and press "a" on the USB
keyboard and you get Control-a like with Windows USB) and works
fine for console and X.

You do need to make a *tiny* patch the kernel source tree so that the
function "handle_scancode" is exported from keyboard.c though.

  $ cd /usr/src/linux
  $ patch -p0 < kbd.patch

And, of course, then, you need to rebuild and install the kernel.

** [Vojtech]: Alternately, just 'insmod kbd-stub', if you don't want
to use the keyboard and are too lazy to patch the kernel.

Keyboard map
------------

I'm including a stupid utility "mkmap" which generates the USB->serial
keymap.  It takes in maps/serial.map (the current serial keymap,
generated by "dumpkeys"), maps/usb.map (the USB keymap), and
maps/fixup.map (fixes for e0 keys and misc.) and spits out keymap.c
Anyway, it is not beautiful but should serve its purpose for the
moment.

Other changes
-------------
uhci.c:
  * added a context value to the irq callback function
    (this is exactly like the "dev_id" field to request_irq)
  * played with uhci_reset_port to get better hot-plug results
    (eg. do a wait_ms(200) before calling uhci_reset_port)
usb.c:
  * disconnect all devices after uhci-control thread is killed
  * skip over the HID descriptor
  * disconnect the high-level driver in usb_disconnect

