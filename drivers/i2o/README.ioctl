
Linux I2O User Space Interface
rev 0.3 - 04/20/99

=============================================================================
Originally written by Deepak Saxena(deepak.saxena@intel.com)
Currently maintained by Deepak Saxena(deepak.saxena@intel.com)
=============================================================================

I. Introduction

The Linux I2O susbsytem provides a set of ioctl() commands than can be
utilized by user space applications to communicate with IOPs and devices
on individual IOPs. This document defines the specific ioctl() commands
that are available to the user and provides examples of their uses.

This document assumes the reader is familiar with or has access to the 
I2O specification as no I2O message parameters are outlined.  For information 
on the specification, see http://www.i2osig.org

This document and the I2O user space interface are currently maintained
by Deepak Saxena.  Please send all comments, errata, and bug fixes to
deepak.saxena@intel.com

II. IOP Access

Access to the I2O subsystem is provided through the device file named 
/dev/i2octl.  This file is a character file with major number 10 and minor
number 166.  It can be created through the following command:

   mknod /dev/i2octl c 10 166

III. Determining the IOP Count

   SYNOPSIS 

   ioctl(fd, I2OGETIOPS,  int *count);

   u8 count[MAX_I2O_CONTROLLERS];

   DESCRIPTION

   This function returns the system's active IOP table.  count should
   point to a buffer containing MAX_I2O_CONTROLLERS entries.  Upon 
   returning, each entry will contain a non-zero value if the given
   IOP unit is active, and NULL if it is inactive or non-existent.

   RETURN VALUE.

   Returns 0 if no errors occur, and -1 otherwise.  If an error occurs,
   errno is set appropriately:

      EIO      Unkown error

IV. ExecHrtGet Message

   SYNOPSIS 
 
   ioctl(fd, I2OHRTGET, struct i2o_cmd_hrt *hrt);

      struct i2o_cmd_hrtlct
      {
         u32   iop;      /* IOP unit number */
         void  *resbuf;  /* Buffer for result */
         u32   *reslen;  /* Buffer length in bytes */
      };

   DESCRIPTION

   This function posts an ExecHrtHet message to the IOP specified by
   hrt->iop and returns the data in the buffer pointed to by hrt->buf
   The size of the data written is placed into the memory pointed to
   by hrt->len.

   RETURNS

   This function returns 0 if no errors occur. If an error occurs, -1 
   is returned and errno is set appropriately:

      ETIMEDOUT   Timeout waiting for reply message
      ENOMEM      Kernel memory allocation error
      ENOBUFS     Buffer not large enough.  If this occurs, the required
                  buffer length is written into *(hrt->reslen)
      EFAULT      Invalid user space pointer was passed
      ENXIO       Invalid IOP number
      EIO         Unkown error
  
V. ExecLctNotify Message
   
   SYNOPSIS 
 
   ioctl(fd, I2OLCTGET, struct i2o_cmd_lct *lct);

      struct i2o_cmd_hrtlct
      {
         u32   iop;      /* IOP unit number */
         void  *resbuf;  /* Buffer for result */
         u32   *reslen;  /* Buffer length in bytes */
      };

   DESCRIPTION

   This function posts an ExecLctGet message to the IOP specified by 
   lct->iop and returns the data in the buffer pointed to by lct->buf
   The size of the data written is placed into the memory pointed to
   by lct->reslen.

   RETURNS

   This function returns 0 if no errors occur. If an error occurs, -1 
   is returned and errno is set appropriately:

      ETIMEDOUT   Timeout waiting for reply message
      ENOMEM      Kernel memory allocation error
      ENOBUFS     Buffer not large enough.  If this occurs, the required
                  buffer length is written into *(lct->reslen)
      EFAULT      Invalid user space pointer was passed
      ENXIO       Invalid IOP number
      EIO         Unkown error

VI. UtilParamsSet Message
   
   SYNOPSIS 
 
   ioctl(fd, I2OPARMSET, struct i2o_parm_setget *ops);

      struct i2o_cmd_psetget
      {
         u32   iop;      /* IOP unit number */
         u32   tid;      /* Target device TID */
         void  *opbuf;   /* Operation List buffer */
         u32   oplen;    /* Operation List buffer length in bytes */
         void  *resbuf;  /* Result List buffer */
         u32   *reslen;  /* Result List buffer length in bytes */
      };

   DESCRIPTION

   This function posts a UtilParamsSet message to the device identified
   by ops->iop and ops->tid.  The operation list for the message is 
   sent through the ops->oplen buffer, and the result list is written
   into the buffer pointed to by ops->oplen.  The number of bytes 
   written is placed into *(ops->reslen). 

   RETURNS

   The return value is the size in bytes of the data written into
   ops->resbuf if no errors occur.  If an error occurs, -1 is returned 
   and errno is set appropriatly:

      ETIMEDOUT   Timeout waiting for reply message
      ENOMEM      Kernel memory allocation error
      ENOBUFS     Buffer not large enough.  If this occurs, the required
                  buffer length is written into *(ops->reslen)
      EFAULT      Invalid user space pointer was passed
      ENXIO       Invalid IOP number
      EIO         Unkown error

   A return value of 0 does not mean that the value was actually
   changed properly on the IOP.  The user should check the result
   list to determine the specific status of the transaction.

VII. UtilParamsGet Message
   
   SYNOPSIS 
 
   ioctl(fd, I2OPARMGET, struct i2o_parm_setget *ops);

      struct i2o_parm_setget
      {
         u32   iop;      /* IOP unit number */
         u32   tid;      /* Target device TID */
         void  *opbuf;   /* Operation List buffer */
         u32   oplen;    /* Operation List buffer length in bytes */
         void  *resbuf;  /* Result List buffer */
         u32   *reslen;  /* Result List buffer length in bytes */
      };

   DESCRIPTION

   This function posts a UtilParamsGet message to the device identified
   by ops->iop and ops->tid.  The operation list for the message is 
   sent through the ops->oplen buffer, and the result list is written
   into the buffer pointed to by ops->oplen.  The actual size of data
   written is placed into *(ops->reslen).

   RETURNS

      ETIMEDOUT   Timeout waiting for reply message
      ENOMEM      Kernel memory allocation error
      ENOBUFS     Buffer not large enough.  If this occurs, the required
                  buffer length is written into *(ops->reslen)
      EFAULT      Invalid user space pointer was passed
      ENXIO       Invalid IOP number
      EIO         Unkown error

   A return value of 0 does not mean that the value was actually
   properly retreived.  The user should check the result list 
   to determine the specific status of the transaction.

VIII. ExecSwDownload Message
   
   SYNOPSIS 
 
   ioctl(fd, I2OSWDL, struct i2o_sw_xfer *sw);

      struct i2o_sw_xfer
      {
         u32   iop;       /* IOP unit number */
         u8    dl_flags;  /* DownLoadFlags field */
         u8    sw_type;   /* Software type */
         u32   sw_id;     /* Software ID */
         void  *buf;      /* Pointer to software buffer */
         u32   *swlen;    /* Length of software data */        
         u32   *maxfrag;  /* Number of fragments */
         u32   *curfrag;  /* Current fragment number */
      };

   DESCRIPTION

   This function downloads the software pointed to by  sw->buf to the
   iop identified by sw->iop. The DownloadFlags, SwID, and SwType fields
   of the ExecSwDownload message are filed in with the values of 
   sw->dl_flags, sw->sw_id, and sw->sw_type.

   Once the ioctl() is called and software transfer begins, the 
   user can read the value *(sw->maxfrag) and *(sw->curfrag) to
   determine the status of the software transfer. As the IOP
   is very slow when it comes to SW transfers, this can be
   used by a separate thread to report status to the user. The
   user _should not_ write to this memory location until the ioctl()
   has returned.

   RETURNS

   This function returns 0 no errors occur. If an error occurs, -1 
   is returned and errno is set appropriatly:

      ETIMEDOUT   Timeout waiting for reply message
      ENOMEM      Kernel memory allocation error
      ENOBUFS     Buffer not large enough.  If this occurs, the required
                  buffer length is written into *(ops->reslen)
      EFAULT      Invalid user space pointer was passed
      ENXIO       Invalid IOP number
      EIO         Unkown error

IX. ExecSwUpload Message
   
   SYNOPSIS 
 
   ioctl(fd, I2OSWUL, struct i2o_sw_xfer *sw);

      struct i2o_sw_xfer
      {
         u32   iop;      /* IOP unit number */
         u8    flags;    /* Unused */
         u8    sw_type;  /* Software type */
         u32   sw_id;    /* Software ID */
         void  *buf;     /* Pointer to software buffer */
         u32   *swlen;   /* Length in bytes of software */        
         u32   *maxfrag; /* Number of fragments */
         u32   *curfrag; /* Current fragment number */
      };

   DESCRIPTION

   This function uploads software from the IOP identified by sw->iop
   and places it in the buffer pointed to by sw->buf.  The SwID, SwType
   and SwSize fields of the ExecSwDownload message are filed in 
   with the values of sw->sw_id, sw->sw_type, sw->swlen, and.  The 
   actual size of the module is written into *(sw->buflen).

   Once the ioctl() is called and software transfer begins, the 
   user can read the value *(sw->maxfrag) and *(sw->curfrag) to
   determine the status of the software transfer.  As the IOP
   is very slow when it comes to SW transfers, this can be
   used by a separate thread to report status to the user. The
   user _should not_ write to this memory location until the ioctl()
   has returned.

   RETURNS

   This function returns 0 if no errors occur.  If an error occurs, -1
   is returned and errno is set appropriatly:

      ETIMEDOUT   Timeout waiting for reply message
      ENOMEM      Kernel memory allocation error
      ENOBUFS     Buffer not large enough.  If this occurs, the required
                  buffer length is written into *(ops->reslen)
      EFAULT      Invalid user space pointer was passed
      ENXIO       Invalid IOP number
      EIO         Unkown error
         
X. ExecSwRemove Message
   
   SYNOPSIS 
 
   ioctl(fd, I2OSWDEL, struct i2o_sw_xfer *sw);

      struct i2o_sw_xfer
      {
         u32   iop;      /* IOP unit number */
         u8    flags;    /* Unused */
         u8    sw_type;  /* Software type */
         u32   sw_id;    /* Software ID */
         void  *buf;     /* Unused */
         u32   *swlen;   /* Length in bytes of software data */        
         u32   *maxfrag; /* Unused */
         u32   *curfrag; /* Unused */
      };

   DESCRIPTION

   This function uploads software from the IOP identified by sw->iop
   and places it in the buffer pointed to by sw->buf.  The SwID, SwType
   and SwSize fields of the ExecSwDownload message are filed in 
   with the values of sw->dl_flags, sw->sw_id, and sw->sw_type.  The 
   actual size of the module is written into *(sw->buflen).

   RETURNS

   This function returns 0 if no errors occur.  If an error occurs, -1
   is returned and errno is set appropriatly:

      ETIMEDOUT   Timeout waiting for reply message
      ENOMEM      Kernel memory allocation error
      ENOBUFS     Buffer not large enough.  If this occurs, the required
                  buffer length is written into *(ops->reslen)
      EFAULT      Invalid user space pointer was passed
      ENXIO       Invalid IOP number
      EIO         Unkown error

X. UtilConfigDialog Message
   
   SYNOPSIS 
 
   ioctl(fd, I2OHTML, struct i2o_html *htquery);

      struct i2o_html
      {
         u32   iop;      /* IOP unit number */
         u32   tid;      /* Target device ID */
         u32   page;     /* HTML page */
         void  *resbuf;  /* Buffer for reply HTML page */
         u32   *reslen;  /* Length in bytes of reply buffer */
         void  *qbuf;    /* Pointer to HTTP query string */
         u32   qlen;     /* Length in bytes of query string buffer */        
      };

   DESCRIPTION

   This function posts an UtilConfigDialog message to the device identified
   by htquery->iop and htquery->tid.  The requested HTML page number is 
   provided by the htquery->page field, and the resultant data is stored 
   in the buffer pointed to by htquery->resbuf.  If there is an HTTP query 
   string that is to be sent to the device, it should be sent in the buffer
   pointed to by htquery->qbuf.  If there is no query string, this field
   should be set to NULL. The actual size of the reply received is written
   into *(htquery->reslen)
  
   RETURNS

   This function returns 0 if no error occur. If an error occurs, -1
   is returned and J errno is set appropriatly:

      ETIMEDOUT   Timeout waiting for reply message
      ENOMEM      Kernel memory allocation error
      ENOBUFS     Buffer not large enough.  If this occurs, the required
                  buffer length is written into *(ops->reslen)
      EFAULT      Invalid user space pointer was passed
      ENXIO       Invalid IOP number
      EIO         Unkown error

XI. Events

    In the process of determining this.  Current idea is to have use
    the select() interface to allow user apps to periodically poll
    the /dev/i2octl device for events.  When select() notifies the user
    that an event is available, the user would call read() to retrieve
    a list of all the events that are pending for the specific device.

=============================================================================
Revision History
=============================================================================

Rev 0.1 - 04/01/99
- Initial revision

Rev 0.2 - 04/06/99
- Changed return values to match UNIX ioctl() standard.  Only return values
  are 0 and -1.  All errors are reported through errno.
- Added summary of proposed possible event interfaces

Rev 0.3 - 04/20/99
- Changed all ioctls() to use pointers to user data instead of actual data
- Updated error values to match the code


