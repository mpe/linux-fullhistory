#!/usr/bin/wish -f

#
# Used to determine size of canvas inserted for booleans. It holds the
# place where the 'm' button goes in a tristate, and keeps the look and feel
# consistent.
#
set modbutton_width 0
set modbutton_height 0

#
# Set to be the x and y position of subwindows.
#
set winx 100
set winy 200

#
# Define some macros we will need to parse the kmenu-config.dat file.
#
proc mainmenu_name { text } {
	message .header.message -width 400 -relief raised -bg grey -text "$text"
	pack .header.label .header.message -side left -padx 15
        wm title . "$text"
}

proc menu_option { w menu_num text } {
	button .f0.x$menu_num -text "$text" -width 50 -command "$w .$w \"$text\""
	pack .f0.x$menu_num -anchor w -pady 1
}

#
# Not used at the moment, but this runs a command in a subprocess and
# displays the result in a window with a scrollbar.
#
proc do_cmd { w command } {
	catch {destroy $w}
	toplevel $w -class Dialog
	frame $w.tb
	text $w.tb.text -relief raised -bd 2 -yscrollcommand "$w.tb.scroll set"
	scrollbar $w.tb.scroll -command "$w.tb.text yview"
	pack $w.tb.scroll -side right -fill y
	pack $w.tb.text -side left

	set oldFocus [focus]
	frame $w.back
	button $w.back.ok -text "OK" -activebackground green -width 20 \
		-command "destroy $w; focus $oldFocus" -state disabled
	button $w.back.ccl -text "Cancel" -activebackground green -width 20 \
		-command "destroy $w; focus $oldFocus"
	pack $w.tb -side top
	pack $w.back.ok $w.back.ccl -side left
	pack $w.back -side bottom -pady 10

	focus $w
	wm geometry $w +30+35	

	$w.tb.text delete 1.0 end
	set f [open |$command]
	while {![eof $f]} {
		$w.tb.text insert end [read $f 256]
	}
	close $f
	$w.back.ok configure -state normal
}

proc load_configfile { w title func } {
	catch {destroy $w}
	toplevel $w -class Dialog
	global loadfile
	frame $w.x
	label $w.bm -bitmap questhead
	pack  $w.bm -pady 10 -side top -padx 10
	label $w.x.l -text "Enter filename:" -relief raised
	entry $w.x.x -width 35 -relief sunken -borderwidth 2 \
		-textvariable loadfile
	pack $w.x.l $w.x.x -anchor w -side left
	pack $w.x -side top -pady 10
	wm title $w "$title" 

	set oldFocus [focus]
	frame $w.f
	button $w.f.back -text "OK" -activebackground green -width 20 \
		-command "destroy $w; focus $oldFocus;$func .fileio"
	button $w.f.canc -text "Cancel" -activebackground red \
		-width 20 -command "destroy $w; focus $oldFocus"
	pack $w.f.back $w.f.canc -side left -pady 10 -padx 45
	pack $w.f -pady 10 -side bottom -padx 10 -anchor w
	focus $w
	wm geometry $w +30+35	
}

proc read_config_file { w } {
	global loadfile
	if { [string length $loadfile] != 0 && [file readable $loadfile] == 1 } then {
		read_config $loadfile
	} else {
		catch {destroy $w}
		toplevel $w -class Dialog
		message $w.m -width 400 -aspect 300 -text \
			"Unable to read file $loadfile" \
			 -relief raised -fg black
		label $w.bm -bitmap error
		pack $w.bm $w.m -pady 10 -side top -padx 10
		wm title $w "Oops" 

		set oldFocus [focus]
		frame $w.f
		button $w.f.back -text "Bummer" -activebackground green \
			-width 10 -command "destroy $w; focus $oldFocus"
		pack $w.f.back -side bottom -pady 10 -anchor s
		pack $w.f -pady 10 -side top -padx 10 -anchor s
		focus $w
		wm geometry $w +30+35
	}
}

proc write_config_file  { w } {
	global loadfile
	if { [string length $loadfile] != 0 
    		&& ([file writable $loadfile] == 1 || ([file exists $loadfile] == 0 && [file writable [file dirname $loadfile]] == 1)) } then {
		writeconfig $loadfile /dev/null
	} else {
		catch {destroy $w}
		toplevel $w -class Dialog
		message $w.m -width 400 -aspect 300 -text \
			"Unable to write file $loadfile" \
			 -relief raised -fg black
		label $w.bm -bitmap error
		pack $w.bm $w.m -pady 10 -side top -padx 10
		wm title $w "Oops" 

		set oldFocus [focus]
		frame $w.f
		button $w.f.back -text "OK" -activebackground green \
			-width 10 -command "destroy $w; focus $oldFocus"
		pack $w.f.back -side bottom -pady 10 -anchor s
		pack $w.f -pady 10 -side top -padx 10 -anchor s
		focus $w
		wm geometry $w +30+35
	}
}

proc read_config { filename } {
	set file1 [open $filename r]
	while { [gets $file1 line] >= 0} {
		if [regexp {([0-9A-Z_]+)=([ynm])} $line foo var value] {
			if { $value == "y" } then { set cmd "global $var; set $var 1" }
			if { $value == "n" } then { set cmd "global $var; set $var 0" }
			if { $value == "m" } then { set cmd "global $var; set $var 2" }
			eval $cmd
		}
		if [regexp {# ([0-9A-Z_]+) is not set} $line foo var] {
			set cmd "global $var; set $var 0"
			eval $cmd
		}
	}
	close $file1
}
proc write_comment { file1 file2 text } {
	puts $file1 "#"
	puts $file1 "# $text"
	puts $file1 "#"
	puts $file2 "/*"
	puts $file2 " * $text"
	puts $file2 " */"
}

proc write_variable { file1 file2 varname variable dep } {
	if { $variable == 0 } \
		then { puts $file1 "# $varname is not set"; \
		       puts $file2 "#undef $varname"} \
	elseif { $variable == 2 || ($dep == 2 && $variable == 1) } \
		then { puts $file1 "$varname=m"; \
		       puts $file2 "#undef $varname"  } \
	elseif { $variable == 1 && $dep != 2 } \
		then { puts $file1 "$varname=y"; \
		       puts $file2 "#define $varname 1" } \
	else { \
	    error "Attempting to write value for variable that is not configured ($varname)." \
	}
}

proc bool {w mnum line text variable default} {
	frame $w.x$line
	global modbutton_width
	global modbutton_height
	radiobutton $w.x$line.y -text "y" -variable $variable -value 1 \
		-width 2 -command "update_menu$mnum .menu$mnum"
	radiobutton $w.x$line.n -text "n"  -variable $variable -value 0 \
		-width 2 -command "update_menu$mnum .menu$mnum"
	canvas $w.x$line.m -width $modbutton_width -relief raised \
		-height $modbutton_height
	button $w.x$line.help -text "Help" -relief raised \
		-command "dohelp .dohelp $variable"
	pack $w.x$line.y $w.x$line.m  -anchor w -side left
	button $w.x$line.l -text "$text" -relief raised 
	pack $w.x$line.n $w.x$line.help $w.x$line.l -anchor w -side left
	pack $w.x$line -anchor w
#
# If we don't know the size yet, update the screen and calculate the size
# of the 'm' button by measuring the size of the 'y' button.  The buttons
# have fixed size anyways, so it should always be correct.
#
	if { $modbutton_width == 0 } then {
		update
		set modbutton_width [winfo width $w.x$line.y]
		set modbutton_height [winfo height $w.x$line.y]
		$w.x$line.m configure -height $modbutton_height \
			-width $modbutton_width
	}
}

proc int { w mnum line text variable default } {
	frame $w.x$line
	button $w.x$line.help -text "Help" -relief raised \
		-command "dohelp .dohelp $variable "
	button $w.x$line.l -text "$text" -relief raised 
	entry $w.x$line.x -width 15 -relief sunken -borderwidth 2 \
		-textvariable $variable
	pack $w.x$line.x $w.x$line.help $w.x$line.l -anchor w -side left
	pack $w.x$line -anchor w
}

proc comment {w line text } {
#nothing done for comments now.
}

proc do_make { w line option dir target target } {
#nothing to do for now.
}

proc dohelp {w varname }  {
	catch {destroy $w}
	toplevel $w -class Dialog

	set filefound 0
	set found 0
	if { [file readable Documentation/Configure.help] == 1} then {
		set f [open Documentation/Configure.help r]
		set filefound 1	
		while {![eof $f]} {
			gets $f line
		        set line1 [string trim $line]
			if { $line1 == $varname } then {
				set found 1
			} else {
				if { $found == 0 } continue 
			}
			if { [string length $line1 ] == 0 } break
			append message $line
		}
		close $f
	}

	if { $found == 0 } then {
		if { $filefound == 0 } then {
		message $w.m -width 400 -aspect 300 -text \
			"No help available - unable to open file Documentation/Configure.help"  -relief raised -fg black
		} else {
		message $w.m -width 400 -aspect 300 -text \
			"No help available for $varname"  -relief raised -fg black
		}
		label $w.bm -bitmap error
		pack $w.bm $w.m -pady 10 -side top -padx 10
		wm title $w "RTFM" 
	} else {
		message $w.m -width 400 -aspect 300 -text $message \
			 -relief raised -fg black
		label $w.bm -bitmap info
		pack $w.bm $w.m -pady 10 -side top -padx 10
		wm title $w "Configuration help" 
	}
	set oldFocus [focus]
	frame $w.f
	button $w.f.back -text "OK" -activebackground green \
		-width 10 -command "destroy $w; focus $oldFocus"
	pack $w.f.back -side bottom -pady 10 -anchor s
	pack $w.f -pady 10 -side top -padx 10 -anchor s
	focus $w
	wm geometry $w +30+35
}

proc wrapup {w }  {
	catch {destroy $w}
	toplevel $w -class Dialog
	message $w.m -width 400 -aspect 300 -text \
		"The linux kernel is now hopefully configured for your setup. Check the top-level Makefile for additional configuration, and do a 'make dep ; make clean' if you want to be sure all the files are correctly re-made."  -relief raised -fg black
	label $w.bm -bitmap info
	pack $w.bm $w.m -pady 10 -side top -padx 10
	wm title $w "Kernel build instructions" 

	set oldFocus [focus]
	frame $w.f
	button $w.f.back -text "OK" -activebackground green \
		-width 10 -command "exit"
	pack $w.f.back -side bottom -pady 10 -anchor s
	pack $w.f -pady 10 -side top -padx 10 -anchor s
	focus $w
	wm geometry $w +30+35

}

proc check_sound_config { num } {
#nothing for now.
}

proc tristate {w mnum line text variable default} {
	frame $w.x$line
	radiobutton $w.x$line.y -text "y" -variable $variable -value 1 \
		-width 2 -command "update_menu$mnum .menu$mnum"
	radiobutton $w.x$line.n -text "n"  -variable $variable -value 0 \
		-width 2 -command "update_menu$mnum .menu$mnum"
	radiobutton $w.x$line.m -text "m"  -variable $variable -value 2 \
		-width 2 -command "update_menu$mnum .menu$mnum"
	button $w.x$line.help -text "Help" -relief raised \
		-command "dohelp .dohelp $variable"
	button $w.x$line.l -text "$text" -relief raised 
	pack $w.x$line.y $w.x$line.m $w.x$line.n $w.x$line.help $w.x$line.l -anchor w -side left
	pack $w.x$line -anchor w
}

proc dep_tristate {w mnum line text variable default} {
	frame $w.x$line
	radiobutton $w.x$line.y -text "y" -variable $variable -value 1 \
		-width 2 -command "update_menu$mnum .menu$mnum"
	radiobutton $w.x$line.n -text "n"  -variable $variable -value 0 \
		-width 2 -command "update_menu$mnum .menu$mnum"
	radiobutton $w.x$line.m -text "m"  -variable $variable -value 2 \
		-width 2 -command "update_menu$mnum .menu$mnum"
	button $w.x$line.help -text "Help" -relief raised \
		-command "dohelp .dohelp $variable"
	button $w.x$line.l -text "$text" -relief raised 
	pack $w.x$line.y $w.x$line.m $w.x$line.n $w.x$line.help $w.x$line.l -anchor w -side left
	pack $w.x$line -anchor w
}


#
# Next set up the particulars for the top level menu, and define a few
# buttons which we will stick down at the bottom.
#
frame .header
label .header.label 

frame .f0 

