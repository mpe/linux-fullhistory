#!/bin/sh -x
# Based on the vmlinux file create the System.map file
# System.map is used by module-init tools and some debugging
# tools to retreive the actual addresses of symbols in the kernel.
#
# Before creating the System.map file as a sideeffect check for
# undefined symbols.
# At least one version of the ARM bin-utils did not error out on
# undefined symbols, so catch them here instead.

# Usage
# mksysmap vmlinux System.map


#####
# Check for undefined symbols.
# Undefined symbols with three leading underscores are ignored since
# they are used by the sparc BTFIXUP logic - and is assumed to be undefined.


if [ "`$NM -u $1 | grep -v ' ___'`" != "" ]; then
	echo "$1: error: undefined symbol(s) found:"
	$NM -u $1 | grep -v ' ___'
	exit 1
fi

#####
# Generate System.map (actual filename passed as second argument)

# $NM produces the following output:
# f0081e80 T alloc_vfsmnt

#   The second row specify the type of the symbol:
#   A = Absolute
#   B = Uninitialised data (.bss)
#   C = Comon symbol
#   D = Initialised data
#   G = Initialised data for small objects
#   I = Indirect reference to another symbol
#   N = Debugging symbol
#   R = Read only
#   S = Uninitialised data for small objects
#   T = Text code symbol
#   U = Undefined symbol
#   V = Weak symbol
#   W = Weak symbol
#   Corresponding small letters are local symbols

# For System.map filter away:
#   a - local absolute symbols
#   U - undefined global symbols
#   w - local weak symbols

# readprofile starts reading symbols when _stext is found, and
# continue until it finds a symbol which is not either of 'T', 't',
# 'W' or 'w'. __crc_ are 'A' and placed in the middle
# so we just ignore them to let readprofile continue to work.
# (At least sparc64 has __crc_ in the middle).

$NM -n $1 | grep -v '\( [aUw] \)\|\(__crc_\)' > $2

